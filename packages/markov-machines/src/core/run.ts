import type { Machine } from "../types/machine.js";
import type { RunOptions, MachineStep, RunResult, SuspendedInstanceInfo } from "../executor/types.js";
import type { Instance, ActiveLeafInfo } from "../types/instance.js";
import type { Command, Resume } from "../types/commands.js";
import type { Message } from "../types/messages.js";
import type { YieldReason } from "../executor/types.js";
import { getInstancePath, getActiveLeaves, isPassiveInstance, getSuspendedInstances, findInstanceById, clearSuspension } from "../types/instance.js";
import { userMessage } from "../types/messages.js";
import { isCommand, isResume } from "../types/commands.js";
import { runCommand } from "./commands.js";

/**
 * Input type for runMachine.
 * Can be a string (user message), a Command object, or a Resume object.
 */
export type RunMachineInput = string | Command | Resume;

/** Check if packStates has any entries */
const hasPackStates = (ps?: Record<string, unknown>): boolean =>
  ps !== undefined && Object.keys(ps).length > 0;

/**
 * Rebuild the tree by replacing the active instance.
 * Follows the same path that getInstancePath would follow.
 */
function rebuildTree(
  updatedActive: Instance,
  ancestors: Instance[],
  packStates?: Record<string, unknown>,
): Instance {
  // If no ancestors, the root IS the active instance
  if (ancestors.length === 0) {
    // Apply packStates directly to root if provided
    if (hasPackStates(packStates)) {
      return { ...updatedActive, packStates };
    }
    return updatedActive;
  }

  // Build from bottom up
  let current: Instance = updatedActive;
  for (let i = ancestors.length - 1; i >= 0; i--) {
    const ancestor = ancestors[i];
    if (!ancestor) continue;

    const isRoot = i === 0;
    const ancestorChildren = ancestor.children ?? [];

    // Clone the ancestor and update its children (replace last element)
    const newChildren = [...ancestorChildren];
    newChildren[newChildren.length - 1] = current;
    current = {
      id: ancestor.id,
      node: ancestor.node,
      state: ancestor.state,
      children: newChildren,
      // Apply packStates to root instance only
      ...(isRoot && hasPackStates(packStates) ? { packStates } : {}),
    };
  }

  return current;
}

/**
 * Rebuild the tree after a cede, removing the ceded child.
 * The parent becomes the new active instance.
 */
function rebuildTreeAfterCede(
  ancestors: Instance[],
  packStates?: Record<string, unknown>,
): Instance {
  // If no ancestors, the root itself ceded - this shouldn't happen
  // since root has no parent to cede to
  if (ancestors.length === 0) {
    throw new Error("Root instance cannot cede - no parent to return to");
  }

  // The direct parent of the ceded child
  const directParent = ancestors[ancestors.length - 1];
  if (!directParent) {
    throw new Error("No direct parent found for cede");
  }

  // Remove the ceded child from the direct parent (remove last element)
  const parentChildren = directParent.children ?? [];
  const newChildren = parentChildren.slice(0, -1);
  const updatedParent: Instance = {
    id: directParent.id,
    node: directParent.node,
    state: directParent.state,
    children: newChildren.length === 0 ? undefined : newChildren,
  };

  // If there's only one ancestor (the direct parent), it becomes the root
  if (ancestors.length === 1) {
    if (hasPackStates(packStates)) {
      return { ...updatedParent, packStates };
    }
    return updatedParent;
  }

  // Otherwise, rebuild the tree with the updated parent
  const remainingAncestors = ancestors.slice(0, -1);
  return rebuildTree(updatedParent, remainingAncestors, packStates);
}

// ============================================================================
// Parallel Execution Helpers
// ============================================================================

/**
 * Flattened result from executor.run() + tree metadata for parallel merging.
 */
interface LeafResult<AppMessage = unknown> {
  /** Index path to this leaf in the tree */
  leafIndex: number[];
  /** Whether this is a passive instance */
  isPassive: boolean;
  /** Instance ID for attribution */
  instanceId: string;
  /** Updated instance from executor */
  instance: Instance;
  /** Messages generated by this leaf */
  messages: Message<AppMessage>[];
  /** Why this leaf yielded */
  yieldReason: YieldReason;
  /** Updated pack states (only from non-passive) */
  packStates?: Record<string, unknown>;
  /** Cede content if yielded via cede (string or Message[]) */
  cedeContent?: string | Message<AppMessage>[];
}

/**
 * Result of merging all leaf results.
 */
interface MergedResult<AppMessage = unknown> {
  /** Updated instance tree */
  instance: Instance;
  /** All messages from all leaves */
  messages: Message<AppMessage>[];
  /** Overall yield reason (tool_use if any leaf needs more work) */
  yieldReason: YieldReason;
  /** Whether any leaf ceded */
  hasCede: boolean;
  /** Cede contents from ceded leaves */
  cedeContents: Array<{ instanceId: string; content: string | Message<AppMessage>[] | undefined }>;
}

/**
 * Update a leaf instance at the given index path.
 */
function updateLeafAtIndex(
  root: Instance,
  indices: number[],
  updater: (leaf: Instance) => Instance,
): Instance {
  if (indices.length === 0) return updater(root);

  const [head, ...rest] = indices;
  const children = root.children ?? [];
  const updated = children.map((c, i) => i === head ? updateLeafAtIndex(c, rest, updater) : c);

  return {
    ...root,
    children: updated.length === 0 ? undefined : updated,
  };
}

/**
 * Remove a leaf instance at the given index path.
 */
function removeLeafAtIndex(root: Instance, indices: number[]): Instance {
  const children = root.children ?? [];

  if (indices.length === 1) {
    const [idx] = indices;
    const filtered = children.filter((_, i) => i !== idx);
    return {
      ...root,
      children: filtered.length === 0 ? undefined : filtered,
    };
  }

  const [head, ...rest] = indices;
  const updated = children.map((c, i) => i === head ? removeLeafAtIndex(c, rest) : c);

  return {
    ...root,
    children: updated.length === 0 ? undefined : updated,
  };
}

/**
 * Wrap messages with source instance metadata.
 */
function wrapMessages<AppMessage>(
  messages: Message<AppMessage>[],
  sourceInstanceId: string,
): Message<AppMessage>[] {
  return messages.map(msg => {
    const existing = (msg as { metadata?: Record<string, unknown> }).metadata;
    if (existing?.sourceInstanceId && existing.sourceInstanceId !== sourceInstanceId) {
      console.warn(
        `[wrapMessages] Overwriting sourceInstanceId: ${existing.sourceInstanceId} -> ${sourceInstanceId}`
      );
    }
    return {
      ...msg,
      metadata: { ...existing, sourceInstanceId },
    };
  }) as Message<AppMessage>[];
}

/**
 * Update an instance in the tree by ID.
 */
function updateInstanceById(
  root: Instance,
  targetId: string,
  updater: (inst: Instance) => Instance,
): Instance {
  if (root.id === targetId) {
    return updater(root);
  }

  const children = root.children;
  if (!children || children.length === 0) {
    return root;
  }

  return {
    ...root,
    children: children.map((c) => updateInstanceById(c, targetId, updater)),
  };
}

/**
 * Merge results from parallel leaf execution.
 * Processes in descending index order so removals don't invalidate later indices.
 */
function mergeLeafResults<AppMessage>(
  root: Instance,
  results: LeafResult<AppMessage>[],
): MergedResult<AppMessage> {
  let instance = root;
  const allMessages: Message<AppMessage>[] = [];
  const cedeContents: Array<{ instanceId: string; content: string | Message<AppMessage>[] | undefined }> = [];
  let hasCede = false;
  let overallYieldReason: YieldReason = "end_turn";
  const packStateUpdates: Record<string, unknown> = {};

  // Sort descending by leaf index (process later/deeper indices first)
  const sorted = [...results].sort((a, b) => {
    for (let i = Math.max(a.leafIndex.length, b.leafIndex.length) - 1; i >= 0; i--) {
      if ((a.leafIndex[i] ?? -1) !== (b.leafIndex[i] ?? -1)) {
        return (b.leafIndex[i] ?? -1) - (a.leafIndex[i] ?? -1);
      }
    }
    return 0;
  });

  for (const leaf of sorted) {
    const { leafIndex, isPassive, instanceId, messages, yieldReason, packStates, cedeContent } = leaf;

    // Only non-passive can update pack states
    // Note: Only one non-passive leaf can exist at a time (validated at lines 439-445),
    // so pack state conflicts between leaves cannot occur. This assignment is safe.
    if (!isPassive && packStates) {
      Object.assign(packStateUpdates, packStates);
    }

    // Passive end_turn without cede -> warning (but don't propagate as machine end_turn)
    if (isPassive && yieldReason === "end_turn") {
      console.warn(
        `[runMachine] Passive instance ${instanceId} returned end_turn without ceding. ` +
        `This is unexpected - passive nodes should cede to return control to parent. ` +
        `Treating as if passive work is complete (not propagating end_turn to machine).`
      );
      // Continue processing - don't let passive end_turn affect machine state
      continue;
    }

    // Cede -> remove leaf
    if (yieldReason === "cede") {
      instance = removeLeafAtIndex(instance, leafIndex);
      cedeContents.push({ instanceId, content: cedeContent });
      allMessages.push(...wrapMessages(messages, instanceId));
      hasCede = true;
      continue;
    }

    // Normal -> update leaf
    instance = updateLeafAtIndex(instance, leafIndex, () => leaf.instance);
    allMessages.push(...wrapMessages(messages, instanceId));

    if (yieldReason === "tool_use" || yieldReason === "max_tokens") {
      overallYieldReason = "tool_use";
    }
  }

  // Apply pack states to root
  if (Object.keys(packStateUpdates).length > 0) {
    instance = { ...instance, packStates: { ...instance.packStates, ...packStateUpdates } };
  }

  return { instance, messages: allMessages, yieldReason: overallYieldReason, hasCede, cedeContents };
}

/**
 * Run the machine with user input or command.
 * Yields MachineStep for each inference call or command execution.
 * Continues until there's a text response or max steps exceeded.
 *
 * When input is a Command:
 * - Execute command via runCommand()
 * - Yield step with yieldReason "command"
 * - Return immediately (caller handles any cascade)
 *
 * @typeParam AppMessage - The application message type for structured outputs (defaults to unknown).
 */
export async function* runMachine<AppMessage = unknown>(
  machine: Machine<AppMessage>,
  input: RunMachineInput,
  options?: RunOptions<AppMessage>,
): AsyncGenerator<MachineStep<AppMessage>> {
  // Handle Resume input
  if (isResume(input)) {
    const targetInstance = findInstanceById(machine.instance, input.instanceId);
    if (!targetInstance) {
      throw new Error(`Instance not found: ${input.instanceId}`);
    }
    if (!targetInstance.suspended) {
      throw new Error(`Instance ${input.instanceId} is not suspended`);
    }
    if (targetInstance.suspended.suspendId !== input.suspendId) {
      throw new Error(
        `Suspend ID mismatch: expected ${targetInstance.suspended.suspendId}, got ${input.suspendId}`
      );
    }

    // Clear the suspended field
    const updatedInstance = updateInstanceById(
      machine.instance,
      input.instanceId,
      clearSuspension,
    );

    yield {
      instance: updatedInstance,
      messages: [userMessage(`[Resumed instance ${input.instanceId}]`)],
      yieldReason: "command",
      done: false, // Not done - resumed instance should continue
    };
    return;
  }

  // Handle Command input
  if (isCommand(input)) {
    const { machine: updatedMachine, result } = await runCommand(
      machine,
      input.name,
      input.input,
      input.instanceId,
    );

    // Create a message for history tracking
    const commandMessage = result.success
      ? `[Command: ${input.name} executed]`
      : `[Command: ${input.name} failed - ${result.error}]`;

    yield {
      instance: updatedMachine.instance,
      messages: [userMessage(commandMessage)],
      yieldReason: "command",
      done: true,
    };
    return;
  }

  // String input - normal execution
  let currentInstance = machine.instance;
  let currentInput = input;

  // Base history from before this run
  const baseHistory: Message<AppMessage>[] = machine.history ?? [];
  let currentHistory: Message<AppMessage>[] = baseHistory;

  const maxSteps = options?.maxSteps ?? 50;
  let steps = 0;
  let tokenRecoveryAttempted = false;

  while (steps < maxSteps) {
    steps++;

    // Get all active leaves for parallel execution
    const activeLeaves = getActiveLeaves(currentInstance);

    if (activeLeaves.length === 0) {
      // Check if all leaves are suspended
      const suspendedInstances = getSuspendedInstances(currentInstance);
      if (suspendedInstances.length > 0) {
        // All leaves are suspended - yield awaiting_resume
        const suspendedInfo: SuspendedInstanceInfo[] = suspendedInstances.map((inst) => ({
          instanceId: inst.id,
          suspendId: inst.suspended!.suspendId,
          reason: inst.suspended!.reason,
          metadata: inst.suspended!.metadata,
        }));
        yield {
          instance: currentInstance,
          messages: [],
          yieldReason: "awaiting_resume",
          done: true,
          suspendedInstances: suspendedInfo,
        };
        return;
      }
      throw new Error("No active instances found");
    }

    // Validate: max 1 non-passive leaf
    const nonPassiveLeaves = activeLeaves.filter(l => !l.isPassive);
    if (nonPassiveLeaves.length > 1) {
      throw new Error(
        `Invalid state: ${nonPassiveLeaves.length} non-passive active leaves. ` +
        `At most one instance can receive user input per step.`
      );
    }

    if (options?.debug) {
      console.log(`[runMachine] Step ${steps}/${maxSteps}`);
      console.log(`[runMachine]   Active leaves: ${activeLeaves.length} (${nonPassiveLeaves.length} non-passive)`);
    }

    // Execute all leaves in parallel
    const results = await Promise.all(
      activeLeaves.map(async ({ path, leafIndex, isPassive }) => {
        const leaf = path[path.length - 1]!;
        const ancestors = path.slice(0, -1);

        if (options?.debug) {
          const instructions = leaf.node.instructions;
          console.log(`[runMachine]   Leaf ${leafIndex.join('.')}: ${instructions.slice(0, 40)}... (passive: ${isPassive})`);
        }

        const result = await machine.charter.executor.run(
          machine.charter,
          leaf,
          ancestors,
          isPassive ? "" : currentInput, // Passive nodes don't receive user input
          { ...options, history: currentHistory, currentStep: steps, maxSteps },
        );

        // Flatten RunResult into LeafResult
        return {
          leafIndex,
          isPassive,
          instanceId: leaf.id,
          ...result,
        } as LeafResult<AppMessage>;
      })
    );

    if (options?.debug) {
      for (const r of results) {
        console.log(`[runMachine]   Leaf ${r.leafIndex.join('.')} result: ${r.yieldReason}, ${r.messages.length} messages`);
      }
    }

    // Single leaf path (backwards compatible)
    if (activeLeaves.length === 1) {
      const result = results[0]!;
      const leafInfo = activeLeaves[0]!;
      const ancestors = leafInfo.path.slice(0, -1);

      // Handle cede: rebuild tree without the ceded child
      if (result.yieldReason === "cede") {
        currentInstance = rebuildTreeAfterCede(ancestors, result.packStates);
        const cedingInstanceId = result.instanceId;

        // Yield cede step (never final - parent needs to respond)
        yield {
          instance: currentInstance,
          messages: result.messages,
          yieldReason: "cede",
          done: false,
          cedeContent: result.cedeContent,
        };

        // Prepare for parent's turn with cede content
        if (result.cedeContent !== undefined) {
          if (typeof result.cedeContent === "string") {
            // String content becomes a user message
            const cedeMessage = userMessage<AppMessage>(result.cedeContent, cedingInstanceId);
            currentHistory = [...baseHistory, cedeMessage];
          } else {
            // Message[] content is appended directly
            currentHistory = [...baseHistory, ...result.cedeContent];
          }
        } else {
          currentHistory = baseHistory;
        }
        currentInput = "";
        continue;
      }

      // Normal case: rebuild tree with updated instance
      currentInstance = rebuildTree(result.instance, ancestors, result.packStates);

      // Handle max_tokens: give LLM one recovery chance
      if (result.yieldReason === "max_tokens" && !tokenRecoveryAttempted) {
        tokenRecoveryAttempted = true;
        if (options?.debug) {
          console.log(`[runMachine] max_tokens hit, attempting recovery...`);
        }

        // Yield the partial step (not final)
        yield {
          instance: currentInstance,
          messages: result.messages,
          yieldReason: result.yieldReason,
          done: false,
        };

        // Add recovery message and continue
        const recoveryMessage = userMessage<AppMessage>(
          `[System: Your response was cut off due to length limits. Please provide a brief summary of your findings and respond to the user now. Do not use any tools - just give your final answer.]`
        );
        currentHistory = [...currentHistory, ...(result.messages as Message<AppMessage>[]), recoveryMessage];
        currentInput = "";
        continue;
      }

      // Determine if this is the final step
      const isFinal = result.yieldReason === "end_turn" ||
                      result.yieldReason === "max_tokens";

      yield {
        instance: currentInstance,
        messages: result.messages,
        yieldReason: result.yieldReason,
        done: isFinal,
      };

      if (isFinal) {
        return;
      }

      // Not final - continue to next step
      currentHistory = [...currentHistory, ...(result.messages as Message<AppMessage>[])];
      currentInput = "";
      continue;
    }

    // Multi-leaf path (parallel execution)
    const merged = mergeLeafResults(currentInstance, results);
    currentInstance = merged.instance;

    // Handle cede contents - add them as messages for parent context
    // NOTE: When one leaf cedes while siblings continue, the cede content is added
    // to shared history. This means sibling context may see messages from the ceding
    // branch. This is a known limitation - revisit if isolation is needed.
    if (merged.hasCede && merged.cedeContents.length > 0) {
      for (const { instanceId, content } of merged.cedeContents) {
        if (content !== undefined) {
          if (typeof content === "string") {
            // String content becomes a user message
            const cedeMessage = userMessage<AppMessage>(content, instanceId);
            currentHistory = [...currentHistory, cedeMessage];
          } else {
            // Message[] content is appended directly
            currentHistory = [...currentHistory, ...content];
          }
        }
      }
    }

    // Yield the merged step
    const isFinal = merged.yieldReason === "end_turn";
    yield {
      instance: currentInstance,
      messages: merged.messages,
      yieldReason: merged.yieldReason,
      done: isFinal,
    };

    if (isFinal) {
      return;
    }

    // Not final - continue to next step
    currentHistory = [...currentHistory, ...(merged.messages as Message<AppMessage>[])];
    currentInput = "";
  }

  throw new Error(`Max steps (${maxSteps}) exceeded`);
}

/**
 * Run the machine to completion, returning only the final step.
 * Convenience wrapper for cases that don't need step-by-step control.
 *
 * @typeParam AppMessage - The application message type for structured outputs (defaults to unknown).
 */
export async function runMachineToCompletion<AppMessage = unknown>(
  machine: Machine<AppMessage>,
  input: RunMachineInput,
  options?: RunOptions<AppMessage>,
): Promise<MachineStep<AppMessage>> {
  let lastStep: MachineStep<AppMessage> | null = null;
  for await (const step of runMachine(machine, input, options)) {
    lastStep = step;
  }
  if (!lastStep) {
    throw new Error("No steps produced");
  }
  return lastStep;
}
