import type { Machine } from "../types/machine.js";
import type { RunOptions, MachineStep, RunResult, SuspendedInstanceInfo } from "../executor/types.js";
import type { Instance, ActiveLeafInfo } from "../types/instance.js";
import type { Command, Resume } from "../types/commands.js";
import type { Message } from "../types/messages.js";
import type { YieldReason } from "../executor/types.js";
import { getActiveLeaves, isWorkerInstance, getSuspendedInstances, findInstanceById, clearSuspension } from "../types/instance.js";
import { userMessage, assistantMessage } from "../types/messages.js";
import type { OutputBlock } from "../types/messages.js";
import { isCommand, isResume } from "../types/commands.js";
import { runCommand } from "./commands.js";

/**
 * Input type for runMachine.
 * Can be a string (user message), a Command object, or a Resume object.
 */
export type RunMachineInput = string | Command | Resume;

/** Check if packStates has any entries */
const hasPackStates = (ps?: Record<string, unknown>): boolean =>
  ps !== undefined && Object.keys(ps).length > 0;

// ============================================================================
// Parallel Execution Helpers
// ============================================================================

/**
 * Flattened result from executor.run() + tree metadata for parallel merging.
 * Exported for use by voice package.
 */
export interface LeafResult<AppMessage = unknown> {
  /** Index path to this leaf in the tree */
  leafIndex: number[];
  /** Whether this is a worker instance */
  isWorker: boolean;
  /** Instance ID for attribution */
  instanceId: string;
  /** Updated instance from executor */
  instance: Instance;
  /** Messages generated by this leaf */
  messages: Message<AppMessage>[];
  /** Why this leaf yielded */
  yieldReason: YieldReason;
  /** Updated pack states (only from non-worker) */
  packStates?: Record<string, unknown>;
  /** Cede content if yielded via cede (string or Message[]) */
  cedeContent?: string | Message<AppMessage>[];
}

/**
 * Result of merging all leaf results.
 * Exported for use by voice package.
 */
export interface MergedResult<AppMessage = unknown> {
  /** Updated instance tree */
  instance: Instance;
  /** All messages from all leaves */
  messages: Message<AppMessage>[];
  /** Overall yield reason (tool_use if any leaf needs more work) */
  yieldReason: YieldReason;
  /** Whether any leaf ceded */
  hasCede: boolean;
  /** Cede contents from ceded leaves */
  cedeContents: Array<{ instanceId: string; content: string | Message<AppMessage>[] | undefined }>;
}

/**
 * Update a leaf instance at the given index path.
 */
function updateLeafAtIndex(
  root: Instance,
  indices: number[],
  updater: (leaf: Instance) => Instance,
): Instance {
  if (indices.length === 0) return updater(root);

  const [head, ...rest] = indices;
  const children = root.children ?? [];
  const updated = children.map((c, i) => i === head ? updateLeafAtIndex(c, rest, updater) : c);

  return {
    ...root,
    children: updated.length === 0 ? undefined : updated,
  };
}

/**
 * Remove a leaf instance at the given index path.
 */
function removeLeafAtIndex(root: Instance, indices: number[]): Instance {
  const children = root.children ?? [];

  if (indices.length === 1) {
    const [idx] = indices;
    const filtered = children.filter((_, i) => i !== idx);
    return {
      ...root,
      children: filtered.length === 0 ? undefined : filtered,
    };
  }

  const [head, ...rest] = indices;
  const updated = children.map((c, i) => i === head ? removeLeafAtIndex(c, rest) : c);

  return {
    ...root,
    children: updated.length === 0 ? undefined : updated,
  };
}

/**
 * Wrap messages with source instance metadata.
 */
function wrapMessages<AppMessage>(
  messages: Message<AppMessage>[],
  sourceInstanceId: string,
): Message<AppMessage>[] {
  return messages.map(msg => {
    const existing = (msg as { metadata?: Record<string, unknown> }).metadata;
    if (existing?.sourceInstanceId && existing.sourceInstanceId !== sourceInstanceId) {
      console.warn(
        `[wrapMessages] Overwriting sourceInstanceId: ${existing.sourceInstanceId} -> ${sourceInstanceId}`
      );
    }
    return {
      ...msg,
      metadata: { ...existing, sourceInstanceId },
    };
  }) as Message<AppMessage>[];
}

/**
 * Update an instance in the tree by ID.
 */
function updateInstanceById(
  root: Instance,
  targetId: string,
  updater: (inst: Instance) => Instance,
): Instance {
  if (root.id === targetId) {
    return updater(root);
  }

  const children = root.children;
  if (!children || children.length === 0) {
    return root;
  }

  return {
    ...root,
    children: children.map((c) => updateInstanceById(c, targetId, updater)),
  };
}

/**
 * Merge results from parallel leaf execution.
 * Processes in descending index order so removals don't invalidate later indices.
 * Exported for use by voice package.
 */
export function mergeLeafResults<AppMessage>(
  root: Instance,
  results: LeafResult<AppMessage>[],
): MergedResult<AppMessage> {
  let instance = root;
  const allMessages: Message<AppMessage>[] = [];
  const cedeContents: Array<{ instanceId: string; content: string | Message<AppMessage>[] | undefined }> = [];
  let hasCede = false;
  let overallYieldReason: YieldReason = "end_turn";
  const packStateUpdates: Record<string, unknown> = {};

  // Sort descending by leaf index (process later/deeper indices first)
  const sorted = [...results].sort((a, b) => {
    for (let i = Math.max(a.leafIndex.length, b.leafIndex.length) - 1; i >= 0; i--) {
      if ((a.leafIndex[i] ?? -1) !== (b.leafIndex[i] ?? -1)) {
        return (b.leafIndex[i] ?? -1) - (a.leafIndex[i] ?? -1);
      }
    }
    return 0;
  });

  for (const leaf of sorted) {
    const { leafIndex, isWorker, instanceId, messages, yieldReason, packStates, cedeContent } = leaf;

    // Only non-worker can update pack states
    // Note: Only one non-worker leaf can exist at a time (validated at lines 439-445),
    // so pack state conflicts between leaves cannot occur. This assignment is safe.
    if (!isWorker && packStates) {
      Object.assign(packStateUpdates, packStates);
    }

    // Worker end_turn without cede -> warning (but don't propagate as machine end_turn)
    if (isWorker && yieldReason === "end_turn") {
      console.warn(
        `[runMachine] Worker instance ${instanceId} returned end_turn without ceding. ` +
        `This is unexpected - worker nodes should cede to return control to parent. ` +
        `Treating as if worker work is complete (not propagating end_turn to machine).`
      );
      // Continue processing - don't let worker end_turn affect machine state
      continue;
    }

    // Cede -> remove leaf
    if (yieldReason === "cede") {
      instance = removeLeafAtIndex(instance, leafIndex);
      cedeContents.push({ instanceId, content: cedeContent });
      allMessages.push(...wrapMessages(messages, instanceId));
      hasCede = true;
      continue;
    }

    // Normal -> update leaf
    instance = updateLeafAtIndex(instance, leafIndex, () => leaf.instance);
    allMessages.push(...wrapMessages(messages, instanceId));

    if (yieldReason === "tool_use" || yieldReason === "max_tokens") {
      overallYieldReason = "tool_use";
    }
  }

  // Apply pack states to root
  if (Object.keys(packStateUpdates).length > 0) {
    instance = { ...instance, packStates: { ...instance.packStates, ...packStateUpdates } };
  }

  return { instance, messages: allMessages, yieldReason: overallYieldReason, hasCede, cedeContents };
}

/**
 * Run the machine with user input or command.
 * Yields MachineStep for each inference call or command execution.
 * Continues until there's a text response or max steps exceeded.
 *
 * When input is a Command:
 * - Execute command via runCommand()
 * - Yield step with yieldReason "command"
 * - Return immediately (caller handles any cascade)
 *
 * @typeParam AppMessage - The application message type for structured outputs (defaults to unknown).
 */
export async function* runMachine<AppMessage = unknown>(
  machine: Machine<AppMessage>,
  input: RunMachineInput,
  options?: RunOptions<AppMessage>,
): AsyncGenerator<MachineStep<AppMessage>> {
  // Handle Resume input
  if (isResume(input)) {
    const targetInstance = findInstanceById(machine.instance, input.instanceId);
    if (!targetInstance) {
      throw new Error(`Instance not found: ${input.instanceId}`);
    }
    if (!targetInstance.suspended) {
      throw new Error(`Instance ${input.instanceId} is not suspended`);
    }
    if (targetInstance.suspended.suspendId !== input.suspendId) {
      throw new Error(
        `Suspend ID mismatch: expected ${targetInstance.suspended.suspendId}, got ${input.suspendId}`
      );
    }

    // Clear the suspended field
    const updatedInstance = updateInstanceById(
      machine.instance,
      input.instanceId,
      clearSuspension,
    );

    yield {
      instance: updatedInstance,
      messages: [userMessage(`[Resumed instance ${input.instanceId}]`)],
      yieldReason: "command",
      done: false, // Not done - resumed instance should continue
    };
    return;
  }

  // Handle Command input
  if (isCommand(input)) {
    const { machine: updatedMachine, result, replyMessages } = await runCommand<AppMessage>(
      machine,
      input.name,
      input.input,
      input.instanceId,
    );

    // Determine instance ID for message attribution
    const targetInstanceId = input.instanceId ?? updatedMachine.instance.id;

    // If command returned a reply, create assistant message for user
    if (replyMessages) {
      // Create the user-facing assistant message
      const userContent = typeof replyMessages.userMessage === "string"
        ? replyMessages.userMessage
        : [{ type: "output" as const, data: replyMessages.userMessage as AppMessage } as OutputBlock<AppMessage>];

      yield {
        instance: updatedMachine.instance,
        messages: [assistantMessage<AppMessage>(userContent, targetInstanceId)],
        yieldReason: "command",
        done: true,
      };
      return;
    }

    // Fallback: Create a message for history tracking
    const commandMessage = result.success
      ? `[Command: ${input.name} executed]`
      : `[Command: ${input.name} failed - ${result.error}]`;

    yield {
      instance: updatedMachine.instance,
      messages: [userMessage(commandMessage, targetInstanceId)],
      yieldReason: "command",
      done: true,
    };
    return;
  }

  // String input - normal execution
  let currentInstance = machine.instance;
  let currentInput = input;

  // Base history from before this run
  const baseHistory: Message<AppMessage>[] = machine.history ?? [];
  let currentHistory: Message<AppMessage>[] = baseHistory;

  const maxSteps = options?.maxSteps ?? 50;
  let steps = 0;
  let tokenRecoveryAttempted = false;

  while (steps < maxSteps) {
    steps++;

    // Get all active leaves for parallel execution
    const activeLeaves = getActiveLeaves(currentInstance);
    if (activeLeaves.length === 0) {
      // Check if all leaves are suspended
      const suspendedInstances = getSuspendedInstances(currentInstance);
      if (suspendedInstances.length > 0) {
        // All leaves are suspended - yield awaiting_resume
        const suspendedInfo: SuspendedInstanceInfo[] = suspendedInstances.map((inst) => ({
          instanceId: inst.id,
          suspendId: inst.suspended!.suspendId,
          reason: inst.suspended!.reason,
          metadata: inst.suspended!.metadata,
        }));
        yield {
          instance: currentInstance,
          messages: [],
          yieldReason: "awaiting_resume",
          done: true,
          suspendedInstances: suspendedInfo,
        };
        return;
      }
      throw new Error("No active instances found");
    }

    // Validate: max 1 non-worker leaf
    const nonWorkerLeaves = activeLeaves.filter(l => !l.isWorker);
    if (nonWorkerLeaves.length > 1) {
      throw new Error(
        `Invalid state: ${nonWorkerLeaves.length} non-worker active leaves. ` +
        `At most one instance can receive user input per step.`
      );
    }

    if (options?.debug) {
      console.log(`[runMachine] Step ${steps}/${maxSteps}`);
      console.log(`[runMachine]   Active leaves: ${activeLeaves.length} (${nonWorkerLeaves.length} non-worker)`);
    }

    // Execute all leaves in parallel
    const results = await Promise.all(
      activeLeaves.map(async ({ path, leafIndex, isWorker }) => {
        const leaf = path[path.length - 1]!;
        const ancestors = path.slice(0, -1);

        if (options?.debug) {
          const instructions = leaf.node.instructions;
          console.log(`[runMachine]   Leaf ${leafIndex.join('.')}: ${instructions.slice(0, 40)}... (worker: ${isWorker})`);
        }

        const result = await machine.charter.executor.run(
          machine.charter,
          leaf,
          ancestors,
          isWorker ? "" : currentInput, // Worker nodes don't receive user input
          { ...options, history: currentHistory, currentStep: steps, maxSteps },
        );

        // Flatten RunResult into LeafResult
        return {
          leafIndex,
          isWorker,
          instanceId: leaf.id,
          ...result,
        } as LeafResult<AppMessage>;
      })
    );

    if (options?.debug) {
      for (const r of results) {
        console.log(`[runMachine]   Leaf ${r.leafIndex.join('.')} result: ${r.yieldReason}, ${r.messages.length} messages`);
      }
    }

    // Process all results through unified path
    const merged = mergeLeafResults(currentInstance, results);
    currentInstance = merged.instance;

    // Single-leaf cede: yield explicit cede step (backwards compatible)
    // Multi-leaf cede (worker cedes while primary continues): just add to history
    if (activeLeaves.length === 1 && merged.hasCede) {
      const cedeInfo = merged.cedeContents[0];
      const cedeContent = cedeInfo?.content;

      // Yield cede step (never final - parent needs to respond)
      yield {
        instance: currentInstance,
        messages: merged.messages,
        yieldReason: "cede",
        done: false,
        cedeContent,
      };

      // Prepare for parent's turn with cede content
      if (cedeContent !== undefined) {
        if (typeof cedeContent === "string") {
          // String content becomes a user message
          const cedeMessage = userMessage<AppMessage>(cedeContent, cedeInfo!.instanceId);
          currentHistory = [...baseHistory, cedeMessage];
        } else {
          // Message[] content is appended directly
          currentHistory = [...baseHistory, ...cedeContent];
        }
      } else {
        currentHistory = baseHistory;
      }
      currentInput = "";
      continue;
    }

    // Multi-leaf cede: add cede contents as messages for parent context
    // NOTE: When one leaf cedes while siblings continue, the cede content is added
    // to shared history. This means sibling context may see messages from the ceding
    // branch. This is a known limitation - revisit if isolation is needed.
    if (merged.hasCede && merged.cedeContents.length > 0) {
      for (const { instanceId, content } of merged.cedeContents) {
        if (content !== undefined) {
          if (typeof content === "string") {
            // String content becomes a user message
            const cedeMessage = userMessage<AppMessage>(content, instanceId);
            currentHistory = [...currentHistory, cedeMessage];
          } else {
            // Message[] content is appended directly
            currentHistory = [...currentHistory, ...content];
          }
        }
      }
    }

    // Handle max_tokens recovery for primary (non-worker) leaf
    // Worker max_tokens is treated as tool_use (keep running) by mergeLeafResults
    const primaryResult = results.find(r => !r.isWorker);
    if (primaryResult?.yieldReason === "max_tokens") {
      if (!tokenRecoveryAttempted) {
        tokenRecoveryAttempted = true;
        if (options?.debug) {
          console.log(`[runMachine] max_tokens hit, attempting recovery...`);
        }

        // Yield the partial step (not final)
        yield {
          instance: currentInstance,
          messages: merged.messages,
          yieldReason: "max_tokens",
          done: false,
        };

        // Add recovery message and continue
        const recoveryMessage = userMessage<AppMessage>(
          `[System: Your response was cut off due to length limits. Please provide a brief summary of your findings and respond to the user now. Do not use any tools - just give your final answer.]`
        );
        currentHistory = [...currentHistory, ...merged.messages, recoveryMessage];
        currentInput = "";
        continue;
      } else {
        // Recovery already attempted, treat as final
        yield {
          instance: currentInstance,
          messages: merged.messages,
          yieldReason: "max_tokens",
          done: true,
        };
        return;
      }
    }

    // Yield the merged step
    const isFinal = merged.yieldReason === "end_turn";
    yield {
      instance: currentInstance,
      messages: merged.messages,
      yieldReason: merged.yieldReason,
      done: isFinal,
    };

    if (isFinal) {
      return;
    }

    // Not final - continue to next step
    currentHistory = [...currentHistory, ...(merged.messages as Message<AppMessage>[])];
    currentInput = "";
  }

  throw new Error(`Max steps (${maxSteps}) exceeded`);
}

/**
 * Run the machine to completion, returning only the final step.
 * Convenience wrapper for cases that don't need step-by-step control.
 *
 * @typeParam AppMessage - The application message type for structured outputs (defaults to unknown).
 */
export async function runMachineToCompletion<AppMessage = unknown>(
  machine: Machine<AppMessage>,
  input: RunMachineInput,
  options?: RunOptions<AppMessage>,
): Promise<MachineStep<AppMessage>> {
  let lastStep: MachineStep<AppMessage> | null = null;
  for await (const step of runMachine(machine, input, options)) {
    lastStep = step;
  }
  if (!lastStep) {
    throw new Error("No steps produced");
  }
  return lastStep;
}
